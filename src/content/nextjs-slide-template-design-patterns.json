{
  "slug": "nextjs-slide-template-design-patterns",
  "title": "Building Flexible Slide Templates with Design Patterns in TypeScript + Next.js",
  "date": "2025-08-16",
  "description": "How I used the Strategy and Factory patterns in a Next.js app to build a flexible system for generating slide templates.",
  "category": "Dev Log",
  "content": "Recently I worked on a small side project: a lesson-planning app where teachers can generate slides based on target vocabulary. What started as a simple React exercise quickly turned into a deep dive into some powerful **design patterns** and TypeScript techniques.\n\nHere’s what I took away.\n\n## The Power of Strategies\n\nInstead of hard-coding logic with `if` or `switch` statements, I learned to isolate behaviors into **strategies**. Each strategy is just a function or object that implements the same contract but behaves differently.\n\nHere are some examples:\n\n* A **quiz** template produces one slide per vocab word.\n* A **story** template produces a single slide that asks for a story using all words.\n* A **fill-in-the-blank** template generates one static instruction.\n\nBecause all of them share the same “shape,” they can be swapped in and out without touching the rest of the code.\n\n## A Factory Without Switch/Case\n\nTo manage multiple strategies, I set up a **registry (factory)**. It’s a simple `Record<TemplateKey, Template>` that maps a key like `\"quiz\"` or `\"story\"` to the corresponding implementation.\n\nThis way, picking a template is as easy as:\n\n```ts\nconst slides = getTemplate(\"quiz\").generateSlides(lesson);\n```\n\nAdding a new template doesn’t break existing code — I just drop it in and register it.\n\n## Contracts as TypeScript Interfaces\n\nTypeScript’s structural typing really shines here. I defined a `Template` **interface**:\n\n```ts\ninterface Template {\n  configure(): Record<string, unknown>;\n  generateSlides(lesson: Lesson): Slide[];\n}\n```\n\nEvery template object must satisfy this contract. If I forget a method or return the wrong type, TypeScript warns me immediately. This enforces consistency while keeping implementations free to vary.\n\n## Pure Compile Step\n\nAnother important idea: keep the slide generation **pure**.\n\n`compileSlides(lesson, key)` is just a function that:\n\n* Looks up the template from the registry.\n* Calls its `generateSlides` method.\n* Returns a fresh array of slides.\n\nNo global state, no DOM side effects. That makes testing and reasoning about the code far easier.\n\n## Testing in Isolation\n\nBecause templates are pure, testing is straightforward. For example, a quiz template test checks:\n\n* One slide per vocab word.\n* Each slide has the expected text.\n\nNo React, no browser required. Just input → output.\n\n## Key Principles Reinforced\n\n* **Strategy pattern:** interchangeable modules with the same contract.\n* **Factory via registry:** avoid brittle `switch` statements.\n* **Interfaces as contracts:** keep APIs consistent.\n* **Pure functions:** isolate logic, easier to test and maintain.\n* **Composable modules:** small files that are easy to extend.\n\nThis little exploration taught me that even a side project is a great playground for solid architectural principles. By practicing strategies, factories, and pure functions, I’m building habits that will scale well beyond this app."
}