{
  "slug": "building-dynamic-task-cards",
  "title": "Building Dynamic Task Cards with Next.js 15 App Router",
  "date": "2025-08-05",
  "description": "How I designed a status-driven card system in Next.js 15 using composable components, config-based rendering, and centralized actions.",
  "category": "Dev Log",
  "content": "## Building a Dynamic Status-Driven Card System in Next.js 15 (App Router)\n\nIn this project, I built a scalable status-driven card component system using Next.js 15 App Router, TypeScript, and a config-driven architecture. The system is designed to dynamically render task cards with varying content, styles, and action buttons — all based on the task's status (`uploaded`, `processing`, `done`, `error`, etc.).\n\n## What I Built\n\n- A flexible `<TaskCard />` component that adapts based on task status\n- Each card displays different informational content, buttons, and styling\n- Uses a central config (`statusConfig.ts`) to control behavior\n- Buttons trigger shared actions defined in one place (`taskActions/index.ts`)\n- Built using the Next.js App Router, with clean folder organization\n- Easy to extend, test, and maintain as the app grows\n\n## The File Structure\n\nHere’s the core structure inside `src/components/TaskCard/`:\n\n```\ncomponents/\n└── TaskCard/\n    ├── actions/\n    │   ├── UploadedActions.tsx\n    │   ├── ProcessingActions.tsx\n    │   ├── DoneActions.tsx\n    │   └── ErrorActions.tsx\n    ├── content/\n    │   ├── UploadedContent.tsx\n    │   ├── ProcessingContent.tsx\n    │   ├── DoneContent.tsx\n    │   └── ErrorContent.tsx\n    ├── taskActions/\n    │   └── index.ts\n    ├── CardHeader.tsx\n    ├── TaskCard.tsx\n    ├── statusConfig.ts\n```\n\nAlso:\n\n```\ndata/\n└── tasks.json\n\nvalidation/\n└── taskSchema.ts\n\nstyles/\n└── globals.css\n```\n\n## Data Flow: How It All Connects\n\n1. Raw task data comes from `tasks.json` or an API\n2. Data is validated with zod (from `taskSchema.ts`)\n3. Each task is passed to `<TaskCard task={...} />`\n4. Inside `TaskCard.tsx`:\n   - It reads the task's `status`\n   - Pulls the matching config from `statusConfig.ts`\n   - Renders:\n     - `<CardHeader />`\n     - Status-specific `<Content />` component\n     - Status-specific `<Actions />` component\n5. Each button in `<Actions />` calls a handler from `taskActions/index.ts`\n\n## How to Alter the Informational Content of a Card\n\nTo change what information is shown in a card for a specific status:\n\nEdit the relevant content file:\n\nFor example, to change the \"done\" card content:\n\n```tsx\n// src/components/TaskCard/content/DoneContent.tsx\nexport default function DoneContent({ task }: { task: Task }) {\n  return (\n    <div>\n      <p>Completed at: {task.completedAt}</p>\n      <p>Uploader: {task.uploader}</p>\n    </div>\n  );\n}\n```\n\nYou can:\n- Add more fields\n- Format dates\n- Show icons, previews, etc.\n\n## How to Alter the Action Buttons on a Card\n\nTo change the action buttons shown for a status:\n\nEdit the corresponding `*.Actions.tsx` file:\n\nExample:\n\n```tsx\n// src/components/TaskCard/actions/UploadedActions.tsx\nexport default function UploadedActions({ task }: { task: Task }) {\n  return (\n    <div className=\"task-actions\">\n      <button onClick={() => taskActions['start-processing'](task)}>\n        Start Processing\n      </button>\n    </div>\n  );\n}\n```\n\nYou can:\n- Add more buttons\n- Change labels\n- Add conditionals\n- Use dynamic rendering with a config list if needed\n\n## How to Alter the Linked Logic Behind Action Buttons\n\nEach action (like Download, Delete, Retry) is handled by a centralized registry:\n\n```ts\n// src/components/TaskCard/taskActions/index.ts\nexport const taskActions = {\n  'start-processing': (task) => { /* logic */ },\n  'retry': (task) => { /* logic */ },\n  'download': (task) => { /* logic */ },\n  'delete': async (task) => { /* logic */ },\n};\n```\n\nTo change what happens when a button is clicked:\n- Edit or add the appropriate function here\n- Add async calls, modal confirmations, or toasts\n- All logic is centralized and testable\n\n## Example: Adding a New Status\n\nLet’s say we add a new task status called `archived`.\n\nYou would:\n\n**1. Update the Zod schema**  \nAdd `archived` to the `TaskStatusSchema` in `taskSchema.ts`:\n\n```ts\nexport const TaskStatusSchema = z.enum([\n  'uploaded',\n  'processing',\n  'done',\n  'error',\n  'archived' // New status\n]);\n```\n\n**2. Add new content component:**\n\n```tsx\n// content/ArchivedContent.tsx\nexport default function ArchivedContent({ task }: { task: Task }) {\n  return <p>This task is archived.</p>;\n}\n```\n\n**3. Add new actions component:**\n\n```tsx\n// actions/ArchivedActions.tsx\nexport default function ArchivedActions({ task }: { task: Task }) {\n  return <button onClick={() => taskActions['restore'](task)}>Restore</button>;\n}\n```\n\n**4. Update `statusConfig.ts`:**\n\n```ts\narchived: {\n  style: 'status-archived',\n  Content: ArchivedContent,\n  Actions: ArchivedActions,\n}\n```\n\n**5. Add a new action handler:**\n\n```ts\n// taskActions/index.ts\n'restore': (task) => {\n  console.log(`Restoring task ${task.id}`);\n}\n```\n\n## Why This Architecture Works\n\n- Separation of concerns – logic, UI, and config are cleanly divided\n- Scalable – adding new statuses or behaviors is easy\n- Maintainable – no duplication across similar components\n- Testable – content and actions can be unit tested\n- Future-proof – easy to plug into APIs or state libraries\n\n## Final Thoughts\n\nThis dynamic card system is a great example of scalable React architecture using Next.js 15 App Router and modern patterns like:\n\n- Config-driven rendering\n- Composable components\n- Action registry pattern\n- Zod schema validation\n\nIt's ideal for task management dashboards, status pipelines, approval flows, and any system where UI changes based on status."
}
