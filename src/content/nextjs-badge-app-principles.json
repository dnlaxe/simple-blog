{
  "slug": "nextjs-badge-app-principles",
  "title": "From JavaScript Basics to a Functional Next.js Badge App",
  "date": "2025-08-15",
  "description": "How I built a small Next.js + TypeScript badge app using solid coding principles like immutability, pure functions, and safe data handling.",
  "category": "Dev Log",
  "content": "When building **Badge Lab**, a small Next.js + TypeScript project that displays and customizes badges.\nI wanted to bake solid coding principles into every part of the app, so it’s clean, safe, and easy to extend.\n\nHere’s how those principles took shape.\n\n## **Functions as Building Blocks**\n\nRather than cramming logic directly into components, I extracted small, focused functions.\nOne favorite is a **higher-order function** called `greeting`:\n\n```ts\nexport const greeting = (x: string) => (name: string) => `${x}, ${name}`;\n```\n\nIt’s a function that returns a function — useful for preconfiguring behavior.\nThis mindset carried into other helpers, like `capitalize` and `snakeToCamel`, that transform strings consistently across the app.\n\n## **Immutability in State Updates**\n\nIn React, mutating state directly can cause subtle bugs.\nTo keep things predictable, I created a utility:\n\n```ts\nexport function addImmutable<T>(xs: readonly T[], x: T): T[] {\n  return [...xs, x];\n}\n```\n\nIn `BadgeRow`, this lets me add a new badge without touching the existing array:\n\n```ts\nconst next = addImmutable(badges, { id, label, tone: \"info\" });\nsetBadges(next);\n```\n\nEvery update produces a fresh copy, making state changes safe and trackable.\n\n## **Destructuring for Clarity**\n\nWorking with badge objects often meant I needed only part of their data.\nDestructuring kept the code clean:\n\n```ts\n{badges.map(({ id, ...rest }) => (\n  <BadgeView key={id} badge={{ id, ...rest }} />\n))}\n```\n\nHere, I pull out the `id` for the `key` prop and pass the rest into the component.\nIt’s concise, and it makes the intent obvious at a glance.\n\n## **Safe Handling of Optional Data**\n\nThe app’s theme system relies on optional color values.\nIf I tried to read a missing property directly, it could crash the app.\nTo avoid that, I used **optional chaining** (`?.`) and **nullish coalescing** (`??`):\n\n```ts\nexport function getThemeColor(theme?: { accent?: string }) {\n  return theme?.accent ?? \"#7aa2ff\";\n}\n```\n\nIf `theme` or `theme.accent` is missing, the function safely falls back to a default color.\n\n## **Pure Functions for Predictable Results**\n\nWhenever possible, I kept my helpers pure — meaning no side effects, no reliance on external state.\n`capitalize` is a good example:\n\n```ts\nexport const capitalize = (s: string) =>\n  s.length === 0 ? s : s[0].toUpperCase() + s.slice(1);\n```\n\nSame input, same output, every time.\nThis predictability makes it easy to test and reuse.\n\n## **Modular Exports and Imports**\n\nTo avoid a tangle of file paths, I grouped utilities in `src/utils` and re-exported them from a single index:\n\n```ts\n// src/utils/index.ts\nexport * from \"./string\";\nexport * from \"./safe\";\nexport * from \"./array\";\n```\n\nNow components can import everything they need from one place, without long relative paths.\n\n## **Testing as a Safety Net**\n\nPure utilities are perfect candidates for quick tests.\nUsing Vitest, I locked in the behavior of my string helpers:\n\n```ts\ntest(\"capitalize\", () => {\n  expect(capitalize(\"hello\")).toBe(\"Hello\");\n});\n```\n\nIf I ever refactor these functions, the tests will catch regressions before they hit production.\n\n## **Bringing It All Together**\n\nIn Badge Lab:\n\n* **Utilities** handle text formatting and safe color access.\n* **Immutability** keeps badge state stable.\n* **Destructuring** makes component code clear and focused.\n* **Optional chaining** ensures the app doesn’t crash if data is missing.\n* **Pure functions** and **tests** keep changes predictable.\n\nThe result is a small but sturdy Next.js app that looks good, works reliably, and is easy to extend — whether that means adding more badge styles, introducing new themes, or reusing utilities in other projects."
}
