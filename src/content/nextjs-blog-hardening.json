{
"slug": "nextjs-blog-hardening",
"title": "Improving Type Safety, Metadata, and Robustness in My Next.js Blog",
"date": "2025-08-04",
"description": "How I made my blog more reliable by tightening types, improving metadata, and validating content at runtime.",
"category": "Dev Log",
"content": "## Why I Made These Improvements\n\nAs my blog project grew, I realized it needed to be more than just functional — it needed to be reliable, maintainable, and predictable. That meant improving how I handled type safety, page metadata, and content validation.\n\n## 1. Adding Type Safety with Zod\n\nInitially, I defined the shape of a blog post using a TypeScript type. But this only helped at compile time. If a blog post JSON file was missing a field or had a typo, the app would still break at runtime.\n\nSo I introduced Zod:\n\n```ts\nimport { z } from 'zod';\n\nexport const postSchema = z.object({\n slug: z.string(),\n title: z.string(),\n description: z.string(),\n date: z.string(),\n category: z.string(),\n content: z.string(),\n});\n\nexport type Post = z.infer<typeof postSchema>;\n```\n\nI used this schema to validate each post file when it was loaded:\n\n```ts\nconst post = postSchema.parse(JSON.parse(fileContents));\n```\n\nThis gave me confidence that each post matched the expected structure.\n\n## 2. Dynamic Metadata Per Post\n\nPreviously, all my pages used the same metadata. That wasn’t great for SEO or sharing.\n\nI fixed this by adding a `generateMetadata()` function in each post page:\n\n```ts\nexport async function generateMetadata({ params }) {\n const post = getPostBySlug(params.slug);\n if (!post) return {};\n\n return {\n title: post.title,\n description: post.description,\n openGraph: {\n title: post.title,\n description: post.description,\n },\n twitter: {\n card: 'summary_large_image',\n title: post.title,\n description: post.description,\n },\n };\n}\n```\n\nNow each post has the correct `<title>` and description tag, and previews better when shared.\n\n## 3. Improving Code Robustness\n\nMy early version assumed all post files were valid. If one was broken, the app would crash.\n\nI wrapped my post loader in a try/catch block:\n\n```ts\ntry {\n const parsed = JSON.parse(fileContents);\n return postSchema.parse(parsed);\n} catch (error) {\n console.warn(`Invalid post file: ${fileName}`, error);\n return null;\n}\n```\n\nThis let me skip bad files gracefully and show a `notFound()` page when needed.\n\n## What I Gained\n\n| Area | Improvement |\n|-----------------|-------------------------------------|\n| Type safety | Zod schema and inferred types |\n| SEO & previews | Per-page metadata with OG tags |\n| Robustness | Runtime validation + fallback logic |\n\nThese changes didn’t require a full rewrite — just a shift in approach. But they made my blog easier to maintain, safer to run, and better to use."
}