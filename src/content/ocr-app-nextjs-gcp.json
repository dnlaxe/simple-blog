{
  "slug": "ocr-app-nextjs-gcp",
  "title": "How I Built a Secure OCR App with Next.js and Google Cloud",
  "date": "2025-08-12",
  "description": "A step-by-step guide on building a secure OCR app with a Next.js frontend and a server-side API using Google Cloud Vision AI.",
  "category": "Project",
  "content": "## Text Extraction using OCR\n\nI recently built a small web app that takes an image of handwritten text and extracts the text using Optical Character Recognition (OCR). This was a great learning experience, as it involved setting up a secure server-side API with Google Cloud Vision AI and building a simple Next.js frontend. Here's a breakdown of the key steps and technologies I used.\n\n### 1. Setting Up the Project\n\nFirst, I created a new Next.js project using the App Router and TypeScript. The command `npx create-next-app@latest ocr-app` handled all the initial setup, giving me a clean directory to start with. The goal was to build a single-page app, so I focused on a simple form with a file input and a button. To handle the styling, I used CSS Modules to keep my component-specific styles organized.\n\n**Key Files:**\n* `app/page.tsx`: The main UI with the file upload form.\n* `app/page.module.css`: The styling for the form and result sections.\n\n### 2. Securing the API with Google Cloud Vision AI\n\nThis was the most critical part from a security perspective. I needed to call the Google Cloud Vision AI API, but I had to keep my credentials secret. The solution was to use a **service account**.\n\n**The steps were:**\n\n1.  **Create a Google Cloud Project** and enable the Vision AI API.\n2.  **Create a service account** with the \"Service Account User\" role, which gives it permission to act on my behalf.\n3.  **Generate a JSON key file** for this service account and save it securely in my project's root directory (`gcp-key.json`).\n4.  **Set an environment variable** (`GOOGLE_APPLICATION_CREDENTIALS`) in my local `.env.local` file to point to this key file.\n\nThis setup ensures that all API calls happen on the server, and the private key never leaves my machine.\n\n### 3. Building the Server-Side API Route\n\nThe Next.js App Router makes it easy to create a secure API endpoint. I created a file at `app/api/ocr/route.ts` that handles incoming image files.\n\nThis API route does several things:\n* **Receives the image** as `FormData`.\n* **Validates the file** to ensure it's an allowed image type (PNG, JPEG, WebP) and under the 10MB size limit.\n* **Initializes the Google Vision client**. Thanks to the `GOOGLE_APPLICATION_CREDENTIALS` environment variable, the client automatically authenticates without me needing to hardcode any credentials.\n* **Calls the `documentTextDetection` endpoint**, which is great for extracting text from documents and handwriting.\n* **Returns the extracted text** as a JSON response to the client.\n\nThis approach keeps all the sensitive logic on the server, away from the user's browser.\n\n**Important Code Snippet (`app/api/ocr/route.ts`):**\n\n```typescript\nimport { NextResponse } from 'next/server';\nimport { ImageAnnotatorClient } from '@google-cloud/vision';\nimport type { NextRequest } from 'next/server';\n\nconst MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const file = formData.get('file');\n\n    if (!file || !(file instanceof File) || file.size > MAX_FILE_SIZE) {\n      return NextResponse.json(\n        { ok: false, error: 'Invalid file or file size exceeds 10MB limit.' },\n        { status: 400 }\n      );\n    }\n\n    const buffer = Buffer.from(await file.arrayBuffer());\n    const client = new ImageAnnotatorClient();\n    const [result] = await client.documentTextDetection(buffer);\n    const fullText = result.fullTextAnnotation?.text;\n\n    if (fullText) {\n      return NextResponse.json({ ok: true, text: fullText }, { status: 200 });\n    } else {\n      return NextResponse.json(\n        { ok: false, error: 'Could not detect any text.' },\n        { status: 404 }\n      );\n    }\n  } catch (error) {\n    console.error('OCR API Error:', error);\n    return NextResponse.json(\n      { ok: false, error: 'An internal server error occurred.' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n### 4. Wiring up the Frontend\n\nOn the client side, I used React's `useState` and `useRef` hooks to manage the file input and show different states:\n* A **loading state** to show \"Processing...\" while waiting for the API response.\n* A **success state** to display the extracted text in a green box.\n* An **error state** to show a helpful message in a red box if something goes wrong.\n\nWhen the user submits the form, the browser's built-in `fetch` API posts the image to my `/api/ocr` endpoint. The response is then used to update the UI accordingly.\n\n**Key Code Snippet (`app/page.tsx`):**\n\n```tsx\n'use client';\nimport { useState, useRef, FormEvent } from 'react';\nimport styles from './page.module.css';\n\nexport default function Home() {\n  const [loading, setLoading] = useState(false);\n  const [result, setResult] = useState<any>(null);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    setLoading(true);\n    setResult(null);\n\n    const file = fileInputRef.current?.files?.[0];\n    if (!file) {\n      setResult({ ok: false, error: 'Please select a file.' });\n      setLoading(false);\n      return;\n    }\n\n    const formData = new FormData();\n    formData.append('file', file);\n\n    try {\n      const response = await fetch('/api/ocr', {\n        method: 'POST',\n        body: formData,\n      });\n\n      const data = await response.json();\n      setResult(data);\n    } catch (err) {\n      setResult({ ok: false, error: 'An unexpected error occurred.' });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    // ... UI elements (form, button, result display)\n  );\n}\n```\n\nThis project was a great way to combine modern frontend and backend technologies while keeping security and simplicity at the forefront. The final app is a simple, secure, and effective tool for converting images of text into digital format."
}